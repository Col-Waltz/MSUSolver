<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Эволюционный алгоритм на графе</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        .input-container {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        .input-field {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        .settings-container {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            background: #f9f9f9;
        }
        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .settings-label {
            width: 250px;
            font-weight: bold;
        }
        .settings-control {
            flex: 1;
            min-width: 200px;
        }
        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 5px;
        }
        .action-button {
            padding: 8px 15px;
            cursor: pointer;
        }
        .action-button:hover:not(:disabled) {
            background-color: #e0e0e0;
        }
        .action-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .clear-button {
            padding: 8px 15px;
            cursor: pointer;
        }
        .button-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }
        .build-button {
            padding: 8px 15px;
            cursor: pointer;
        }
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #controls {
            padding: 10px;
            background: #f0f0f0;
            overflow-y: auto;
            max-height: 50vh;
        }
        #graphs-container {
            flex-grow: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
            padding: 10px;
            background: white;
        }
        .graph-box {
            border: 1px solid #ddd;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }
        .graph-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(240, 240, 240, 0.8);
            padding: 5px;
            text-align: center;
            font-weight: bold;
        }
        .graph-canvas {
            width: 100%;
            height: 100%;
        }
        button {
            padding: 8px 15px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        .sigma-edge-label {
            font-size: 12px;
            fill: #333;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 2px 4px;
            border-radius: 3px;
        }
        input[type="range"] {
            width: 100%;
        }
        select {
            width: 100%;
            padding: 5px;
        }
        input[type="number"] {
            width: 80px;
            padding: 5px;
        }
        .step-counter {
            margin-left: 20px;
            font-weight: bold;
            font-size: 16px;
            color: #333;
            background: #e8f5e8;
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #4CAF50;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/sigma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/plugins/sigma.renderers.edgeLabels.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/plugins/sigma.plugins.dragNodes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/plugins/sigma.layout.forceAtlas2.min.js"></script>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h2>Визуализация эволюционного алгоритма на графе</h2>
            <h5>Введите параметры для запуска эволюционного алгоритма. Число вершин должно быть четным и не менее 10. Число исполнителей должно быть четным и не менее 4.</h5>
            
            <div class="input-container">
                <label for="vertex-count">Число вершин:</label>
                <input type="number" id="vertex-count" class="input-field" min="10" step="2" value="10">
                
                <label for="executor-count">Число исполнителей:</label>
                <input type="number" id="executor-count" class="input-field" min="4" step="2" value="4">
            </div>

            <div class="settings-container" id="settings-container">
                <h3>Настройки алгоритма</h3>
                
                <div class="settings-row">
                    <div class="settings-label">Алгоритм селекции:</div>
                    <div class="settings-control">
                        <select id="selection-algorithm">
                            <option value="roulette">Рулетка</option>
                            <option value="rank">Ранговая</option>
                        </select>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">Вероятность мутации (%):</div>
                    <div class="settings-control">
                        <input type="range" id="mutation-rate" min="0" max="100" value="5">
                        <span id="mutation-rate-value">5%</span>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">Число мутирующих позиций:</div>
                    <div class="settings-control">
                        <input type="range" id="mutation-count" min="1" max="10" value="1">
                        <span id="mutation-count-value">1</span>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">Сохранять лучших исполнителей:</div>
                    <div class="settings-control">
                        <select id="elitism-count">
                            <option value="0">Не сохранять</option>
                            <option value="1" selected>1 лучший</option>
                            <option value="2">2 лучших</option>
                            <option value="3">3 лучших</option>
                            <option value="4">4 лучших</option>
                        </select>
                    </div>
                </div>
            </div>
                
            <div class="action-buttons">
                <button id="start-algorithm" class="action-button">Начать</button>
                <button id="reset-algorithm" class="action-button" disabled>Сброс</button>
                <div style="display: flex; align-items: center;">
                    <button id="step-algorithm" class="action-button" disabled>Сделать шагов:</button>
                    <input type="number" id="step-count" min="1" value="1" style="width: 60px; margin-left: 5px;">
                </div>
                <div class="step-counter" id="step-counter">
                    Шагов выполнено: 0
                </div>
            </div>
        </div>
        
        <div id="graphs-container" style="display: none;">
            <div class="graph-box" id="graph-1">
                <div class="graph-canvas" id="sigma-container-1"></div>
                <div class="graph-label">Исполнитель 1</div>
            </div>
            <div class="graph-box" id="graph-2">
                <div class="graph-canvas" id="sigma-container-2"></div>
                <div class="graph-label">Исполнитель 2</div>
            </div>
            <div class="graph-box" id="graph-3">
                <div class="graph-canvas" id="sigma-container-3"></div>
                <div class="graph-label">Исполнитель 3</div>
            </div>
            <div class="graph-box" id="graph-4">
                <div class="graph-canvas" id="sigma-container-4"></div>
                <div class="graph-label">Исполнитель 4</div>
            </div>
        </div>
    </div>
    
    <script>
	const wrongEdgesWeight = 5;
        const graphInstances = [];
        
        for (let i = 1; i <= 4; i++) {
            const containerId = `sigma-container-${i}`;
            const s = new sigma({
                graph: {
                    nodes: [],
                    edges: []
                },
                renderer: {
                    container: containerId,
                    type: 'canvas'
                },
                settings: {
                    minNodeSize: 2,
                    maxNodeSize: 10,
                    minEdgeSize: 0.5,
                    maxEdgeSize: 1.5,
                    enableEdgeHovering: false,
                    edgeHoverColor: 'default',
                    defaultEdgeHoverColor: '#000',
                    edgeHoverSizeRatio: 1,
                    edgeHoverExtremities: true
                }
            });
            
            graphInstances.push(s);
        }

        let currentSettings = {};
        let isStopped = false;
        let stepCounter = 0;

        function updateStepCounter() {
            document.getElementById('step-counter').textContent = `Шагов выполнено: ${stepCounter}`;
        }

        document.getElementById('mutation-rate').addEventListener('input', function() {
            document.getElementById('mutation-rate-value').textContent = this.value + '%';
        });

        document.getElementById('mutation-count').addEventListener('input', function() {
            document.getElementById('mutation-count-value').textContent = this.value;
        });

        function updateStepButtonState() {
            const stepButton = document.getElementById('step-algorithm');
            if (isStopped) {
                stepButton.disabled = true;
                stepButton.title = "Алгоритм завершен. Нажмите 'Сброс' для нового запуска.";
            } else {
                stepButton.disabled = false;
                stepButton.title = "";
            }
        }

        function fixSettings() {
            currentSettings = {
                selectionAlgorithm: document.getElementById('selection-algorithm').value,
                mutationRate: parseInt(document.getElementById('mutation-rate').value),
                mutationCount: parseInt(document.getElementById('mutation-count').value),
                elitismCount: parseInt(document.getElementById('elitism-count').value),
                vertexCount: parseInt(document.getElementById('vertex-count').value),
                executorCount: parseInt(document.getElementById('executor-count').value)
            };

            isStopped = false;
            stepCounter = 0;
            updateStepCounter();
            updateStepButtonState();
            
            document.getElementById('settings-container').style.opacity = '0.6';
            document.querySelectorAll('#settings-container input, #settings-container select').forEach(el => {
                el.disabled = true;
            });

            document.getElementById('start-algorithm').disabled = true;
            document.getElementById('reset-algorithm').disabled = false;
            document.getElementById('step-algorithm').disabled = false;

            document.getElementById('graphs-container').style.display = 'grid';
        }

        function resetSettings() {
            document.getElementById('settings-container').style.opacity = '1';
            document.querySelectorAll('#settings-container input, #settings-container select').forEach(el => {
                el.disabled = false;
            });

            document.getElementById('start-algorithm').disabled = false;
            document.getElementById('reset-algorithm').disabled = true;
            document.getElementById('step-algorithm').disabled = true;

            document.getElementById('graphs-container').style.display = 'none';

            graphInstances.forEach(instance => {
                instance.graph.clear();
                instance.refresh();
            });

            currentSettings = {};
            isStopped = false;
            stepCounter = 0;
            updateStepCounter();
            window.currentGraphs = null;
        }

        function shouldStop(graphsWithScores) {
            const vertexCount = graphsWithScores[0].representation.length;
            const optimalScore = vertexCount - 1 + wrongEdgesWeight;
            return graphsWithScores.some(graph => graph.score === optimalScore);
        }

        function rangSelection(graphsWithScores) {
            const sorted = [...graphsWithScores].sort((a, b) => a.score - b.score);
    
            const probabilities = sorted.map((graph, index) => {
                const rankWeight = (sorted.length - index) / sorted.length;
                return {
                    graph: graph,
                    probability: rankWeight
                };
            });
    
            const totalProbability = probabilities.reduce((sum, p) => sum + p.probability, 0);
            probabilities.forEach(p => p.probability /= totalProbability);
    
            const parent1 = selectParent(probabilities);
            let parent2;
            do {
                parent2 = selectParent(probabilities);
            } while (parent2 === parent1);
    
            return [parent1, parent2];
        }

        function mutate(representation, mutationRate = 5, mutationCount = 1) {
            const mutated = [...representation];
            const mutationProbability = mutationRate / 100;
            
            for (let i = 0; i < mutated.length; i++) {
                if (Math.random() < mutationProbability) {
                    for (let j = 0; j < mutationCount; j++) {
                        const swapIndex = Math.floor(Math.random() * mutated.length);
                        [mutated[i], mutated[swapIndex]] = [mutated[swapIndex], mutated[i]];
                    }
                }
            }
    
            return mutated;
        }

        function rouletteSelection(graphsWithScores) {
            const totalScore = graphsWithScores.reduce((sum, graph) => sum + graph.score, 0);
            const inverseScores = graphsWithScores.map(graph => {
                return {
                    graph: graph,
                    inverseScore: totalScore - graph.score
                };
            });
            const totalInverseScore = inverseScores.reduce((sum, item) => sum + item.inverseScore, 0);
            
            const probabilities = inverseScores.map(item => {
                return {
                    graph: item.graph,
                    probability: item.inverseScore / totalInverseScore
                };
            });
            
            const parent1 = selectParent(probabilities);
            let parent2;
            do {
                parent2 = selectParent(probabilities);
            } while (parent2 === parent1);
            
            return [parent1, parent2];
        }

        function selectParent(probabilities) {
            const random = Math.random();
            let cumulativeProbability = 0;
            
            for (const p of probabilities) {
                cumulativeProbability += p.probability;
                if (random <= cumulativeProbability) {
                    return p.graph;
                }
            }
            
            return probabilities[probabilities.length - 1].graph;
        }

        function crossover(parent1, parent2) {
            const length = parent1.representation.length;
            
            let point1 = Math.floor(Math.random() * length);
            let point2 = Math.floor(Math.random() * length);
            
            if (point1 > point2) {
                [point1, point2] = [point2, point1];
            }
            
            const child1 = Array(length).fill(null);
            const child2 = Array(length).fill(null);
            
            for (let i = point1; i <= point2; i++) {
                child1[i] = parent2.representation[i];
                child2[i] = parent1.representation[i];
            }
            
            fillRemainingPositions(child1, parent1.representation);
            fillRemainingPositions(child2, parent2.representation);
            
            return [child1, child2];
        }

        function fillRemainingPositions(child, parent) {
            const length = child.length;
            let parentIndex = 0;
            
            for (let i = 0; i < length; i++) {
                if (child[i] === null) {
                    while (parentIndex < length && child.includes(parent[parentIndex])) {
                        parentIndex++;
                    }
                    if (parentIndex < length) {
                        child[i] = parent[parentIndex];
                        parentIndex++;
                    }
                }
            }
        }
        
        function calculateGraphScore(representation) {
            let score = 0;
            
            for (let i = 0; i < representation.length; i++) {
                const current = representation[i];
                const next = representation[(i + 1) % representation.length];
                
                if (Math.abs(current - next) === 1) {
                    score += 1;
                } else {
                    score += wrongEdgesWeight;
                }
            }
            
            return score;
        }

        function algorithmStep(graphsWithScores) {
            if (shouldStop(graphsWithScores)) {
                isStopped = true;
                updateStepButtonState();
                return graphsWithScores;
            }
            
            const newGraphs = [];
            
            const elitismCount = currentSettings.elitismCount;
            const selectionAlgorithm = currentSettings.selectionAlgorithm;
            
            if (elitismCount > 0) {
                const sortedGraphs = [...graphsWithScores].sort((a, b) => a.score - b.score);
                const bestGraphs = sortedGraphs.slice(0, elitismCount);
                bestGraphs.forEach(graph => newGraphs.push({...graph}));
            }
            
            const selectionFunction = selectionAlgorithm === 'rank' ? rangSelection : rouletteSelection;
            
            while (newGraphs.length < graphsWithScores.length) {
                const [parent1, parent2] = selectionFunction(graphsWithScores);
                
                let [child1Rep, child2Rep] = crossover(parent1, parent2);

                child1Rep = mutate(child1Rep, currentSettings.mutationRate, currentSettings.mutationCount);
                child2Rep = mutate(child2Rep, currentSettings.mutationRate, currentSettings.mutationCount);
                
                const child1 = {
                    representation: child1Rep,
                    score: calculateGraphScore(child1Rep)
                };
                
                const child2 = {
                    representation: child2Rep,
                    score: calculateGraphScore(child2Rep)
                };
                
                newGraphs.push(child1, child2);
            }
            
            newGraphs.sort((a, b) => a.score - b.score);
            return newGraphs.slice(0, graphsWithScores.length);
        }

        function createCircularNodes(vertexCount) {
            const nodes = [];
            const centerX = 0.5;
            const centerY = 0.5;
            const radius = 0.4;
            
            for (let i = 1; i <= vertexCount; i++) {
                const angle = (2 * Math.PI * (i - 1)) / vertexCount;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                nodes.push({
                    id: `n${i}`,
                    label: `${i}`,
                    x: x,
                    y: y,
                    size: 1,
                    color: '#666'
                });
            }
            
            return nodes;
        }

        function createEdgesFromRepresentation(representation, instanceIndex) {
            const edges = [];
            const vertexCount = representation.length;
            
            for (let i = 0; i < vertexCount; i++) {
                const source = representation[i];
                const target = representation[(i + 1) % vertexCount];
                
                const isShortEdge = Math.abs(source - target) === 1;
                const edgeColor = isShortEdge ? '#4CAF50' : '#FF5252';
                const edgeSize = isShortEdge ? 1 : 2;
                
                edges.push({
                    id: `e${source}-${target}-${instanceIndex}-${i}`,
                    source: `n${source}`,
                    target: `n${target}`,
                    color: edgeColor,
                    size: edgeSize
                });
            }
            
            return edges;
        }

        function renderGraph(sigmaInstance, graphData, instanceIndex, vertexCount) {
            sigmaInstance.graph.clear();
            
            if (!graphData) {
                document.querySelector(`#graph-${instanceIndex + 1} .graph-label`).textContent = 'Не используется';
                sigmaInstance.refresh();
                return;
            }
            
            const nodes = createCircularNodes(vertexCount);
            nodes.forEach(node => {
                sigmaInstance.graph.addNode({
                    ...node,
                    color: instanceIndex === 0 ? '#FF6B6B' : '#666'
                });
            });
            
            const edges = createEdgesFromRepresentation(graphData.representation, instanceIndex);
            edges.forEach(edge => sigmaInstance.graph.addEdge(edge));
            
            document.querySelector(`#graph-${instanceIndex + 1} .graph-label`).textContent = 
                `Исполнитель ${instanceIndex + 1} | Оценка: ${graphData.score}`;
            
            sigmaInstance.refresh();
        }

        function generateRandomGraphRepresentation(vertexCount) {
            const vertices = Array.from({length: vertexCount}, (_, i) => i + 1);
            
            for (let i = vertices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [vertices[i], vertices[j]] = [vertices[j], vertices[i]];
            }
            
            return vertices;
        }

        function initializeGraphs() {
            const graphsWithScores = [];
            const vertexCount = currentSettings.vertexCount;
            const executorCount = currentSettings.executorCount;
            
            for (let i = 0; i < executorCount; i++) {
                const representation = generateRandomGraphRepresentation(vertexCount);
                const score = calculateGraphScore(representation);
                
                graphsWithScores.push({
                    representation: representation,
                    score: score
                });
            }
            
            graphsWithScores.sort((a, b) => a.score - b.score);
            
            while (graphsWithScores.length < 4) {
                graphsWithScores.push(null);
            }
            
            window.currentGraphs = graphsWithScores;
            window.vertexCount = vertexCount;
            
            for (let i = 0; i < graphInstances.length; i++) {
                renderGraph(graphInstances[i], graphsWithScores[i], i, vertexCount);
            }
        }

        function updateGraphsDisplay(graphsWithScores) {
            for (let i = 0; i < graphInstances.length; i++) {
                renderGraph(graphInstances[i], graphsWithScores[i], i, window.vertexCount);
            }
        }

        document.getElementById('start-algorithm').addEventListener('click', function() {
            const vertexCount = parseInt(document.getElementById('vertex-count').value);
            const executorCount = parseInt(document.getElementById('executor-count').value);
            
            if (vertexCount < 10 || vertexCount % 2 !== 0) {
                alert('Число вершин должно быть четным и не менее 10');
                return;
            }
            
            if (executorCount < 4 || executorCount % 2 !== 0) {
                alert('Число исполнителей должно быть четным и не менее 4');
                return;
            }
            
            fixSettings();
            initializeGraphs();
        });

        document.getElementById('reset-algorithm').addEventListener('click', function() {
            resetSettings();
        });

        document.getElementById('step-algorithm').addEventListener('click', function() {
            if (isStopped) {
                alert("Алгоритм завершен. Нажмите 'Сброс' для нового запуска.");
                return;
            }
            
            const stepCount = parseInt(document.getElementById('step-count').value);
            
            if (!window.currentGraphs) {
                alert('Сначала нажмите "Начать"');
                return;
            }
            
            const activeGraphs = window.currentGraphs.filter(g => g !== null);
            
            if (activeGraphs.length === 0) {
                alert('Нет активных исполнителей');
                return;
            }
            
            let newGraphs = activeGraphs;
            for (let step = 0; step < stepCount; step++) {
                console.log(`Шаг ${step + 1}:`);
                newGraphs = algorithmStep(newGraphs);
                
                stepCounter++;
                updateStepCounter();
                
                if (isStopped) {
                    break;
                }
                
                newGraphs.sort((a, b) => a.score - b.score);
            }
            
            while (newGraphs.length < 4) {
                newGraphs.push(null);
            }
            
            window.currentGraphs = newGraphs;
            updateGraphsDisplay(newGraphs);
        });

        window.addEventListener('load', function() {
            document.getElementById('graphs-container').style.display = 'none';
            updateStepCounter();
        });
    </script>
</body>
</html>
