<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Построение КС логических функций</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .function-container {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        .input-field {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 5px;
        }
        .symbol-button {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .symbol-button:hover {
            background-color: #e0e0e0;
        }
        .add-button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        .add-button:hover {
            background-color: #45a049;
        }
        .remove-button {
            padding: 5px 10px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 5px;
        }
        .remove-button:hover {
            background-color: #d32f2f;
        }
        .button-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .clear-button {
            padding: 8px 12px;
            background-color: #ff9800;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .clear-button:hover {
            background-color: #e68a00;
        }
        .keyboard-container {
            display: none;
        }
        .active-keyboard {
            display: block;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .build-button {
            padding: 10px 15px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        .build-button:hover {
            background-color: #0b7dda;
        }
        .independent-container {
            margin: 20px 0;
            border: 1px solid #aaa;
            padding: 15px;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .independent-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
	.functions-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
	.result-container {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 16px;
        }
        /* Стили для таблиц */
        .tables-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .truth-table {
            border-collapse: collapse;
            margin-top: 20px;
        }
        .truth-table th, .truth-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        .truth-table th {
            background-color: #f2f2f2;
        }
        .table-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h2>Проверочные и диагностические тесты</h2>
            <h5>Этот калькулятор может построить тупиковые проверочные и диагностические тесты по введенной формуле и возможным неисправностям. Логическая формула вводится с использованием всех операций, так как разделение на переменные происходит по операциям. При описании неисправностей выберите характер неисправности и какие переменные неисправность затрагивает. Перечислите переменные через запятую. Будте внимательны некорректные переменные просто не обработаются, так как ребер с такими переменными в КС нет!!</h5>
            
            <div class="independent-container">
                <div class="independent-title">Введите логическую функцию</div>
                <input type="text" class="input-field" id="independent-input">
                <button class="clear-button" id="independent-clear">Очистить</button>
                <div class="keyboard-container" id="independent-keyboard">
		    <div class="button-row">
                        <button class="symbol-button" data-symbol="x1">x1</button>
                        <button class="symbol-button" data-symbol="x2">x2</button>
                        <button class="symbol-button" data-symbol="x3">x3</button>
                        <button class="symbol-button" data-symbol="x4">x4</button>
                        <button class="symbol-button" data-symbol="(">(</button>
                        <button class="symbol-button" data-symbol=")">)</button>
                    </div>
                    <div class="button-row">
                        <button class="symbol-button" data-symbol="∧">∧</button>
                        <button class="symbol-button" data-symbol="∨">∨</button>
                        <button class="symbol-button" data-symbol="¬">¬</button>
                        <button class="symbol-button" data-symbol="⊕">⊕</button>
                        <button class="symbol-button" data-symbol="≡">≡</button>
                        <button class="symbol-button" data-symbol="|">|</button>
                        <button class="symbol-button" data-symbol="→">→</button>
                        <button class="symbol-button" data-symbol="↓">↓</button>
                    </div>
                </div>
            </div>
            
            <div id="functions-container">
		<div class="functions-title">Укажите возможные неисправности</div>
                <div class="function-container" id="function-1">
                    <select class="rule-type" style="margin-right: 10px; padding: 5px;">
                        <option value="break">Обрыв</option>
                        <option value="make">Замыкание</option>
                    </select>
                    <span style="margin-right: 10px;">контактов</span>
                    <input type="text" class="input-field" id="input-1">
                    <button class="clear-button">Очистить</button>
                    <div class="keyboard-container active-keyboard" id="keyboard-1">
                        <div class="button-row">
                            <button class="symbol-button" data-symbol="x1">x1</button>
                            <button class="symbol-button" data-symbol="x2">x2</button>
                            <button class="symbol-button" data-symbol="x3">x3</button>
                            <button class="symbol-button" data-symbol="x4">x4</button>
                            <button class="symbol-button" data-symbol="¬">¬</button>
                            <button class="symbol-button" data-symbol=",">,</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="action-buttons">
                <button id="add-function" class="add-button">Добавить неисправность</button>
                <button id="build-knf" class="build-button">Построить проверочный тест</button>
                <button id="reset-layout" class="build-button">Построить диагностический тест</button>
            </div>
            <div id="tables-container" class="tables-container"></div>
	    <div id="result-container" class="result-container"></div>
        </div>
    </div>

    <script>
	const logicalOps = ["∧", "∨", "⊕", "↓", "|", "→", "≡", "(", ")", "¬"];
        
        class Expr {
            static Var(varname) { return { type: "Var", varname }; }
            static Eq(left, right) { return { type: "Eq", left, right }; }
            static Impl(left, right) { return { type: "Impl", left, right }; }
            static Nor(left, right) { return { type: "Nor", left, right }; }
            static Nand(left, right) { return { type: "Nand", left, right }; }
            static Xor(left, right) { return { type: "Xor", left, right }; }
            static And(left, right) { return { type: "And", left, right }; }
            static Or(left, right) { return { type: "Or", left, right }; }
            static Not(expr) { return { type: "Not", expr }; }
            static Bool(value) { return { type: "Bool", value }; }
        }
        
        function depleteFunc(s) {
	    console.log("Depleted func: ", s);
            return getToken(s, "", []);
        }
        
        function getToken(s, current, result) {
            if (s === "") {
                return current === "" ? result.reverse() : [current, ...result].reverse();
            }
            
            const c = s[0];
            const cs = s.slice(1);
            
            if (logicalOps.includes(c)) {
                return current === "" 
                    ? getToken(cs, "", [c, ...result])
                    : getToken(cs, "", [c, current, ...result]);
            } else if (c === ' ') {
                return getToken(cs, current, result);
            } else if (c === '0' || c === '1') {
                return current === ""
                    ? getToken(cs, "", [c, ...result])
                    : getToken(cs, current + c, result);
            } else {
                return getToken(cs, current + c, result);
            }
        }
        
        function parseExpr(tokens) {
	    console.log("parseExpr", tokens);
            const [expr, remaining] = parseEq(tokens);
            if (remaining.length !== 0) throw new Error("Unexpected tokens remaining");
            return expr;
        }
        
        function parseEq(tokens) {
	    console.log("parseEq", tokens);
            const [left, rest] = parseImpl(tokens);
            if (rest[0] === "≡") {
                const [right, rest2] = parseEq(rest.slice(1));
                return [Expr.Eq(left, right), rest2];
            }
            return [left, rest];
        }
        
        function parseImpl(tokens) {
	    console.log("parseImpl", tokens);
            const [left, rest] = parseNor(tokens);
            if (rest[0] === "→") {
                const [right, rest2] = parseImpl(rest.slice(1));
                return [Expr.Impl(left, right), rest2];
            }
            return [left, rest];
        }
        
        function parseNor(tokens) {
	    console.log("parseNor", tokens);
            const [left, rest] = parseNand(tokens);
            if (rest[0] === "↓") {
                const [right, rest2] = parseNor(rest.slice(1));
                return [Expr.Nor(left, right), rest2];
            }
            return [left, rest];
        }
        
        function parseNand(tokens) {
	    console.log("parseNand", tokens);
            const [left, rest] = parseXor(tokens);
            if (rest[0] === "|") {
                const [right, rest2] = parseNand(rest.slice(1));
                return [Expr.Nand(left, right), rest2];
            }
            return [left, rest];
        }
        
        function parseXor(tokens) {
	    console.log("parseXor", tokens);
            const [left, rest] = parseOr(tokens);
            if (rest[0] === "⊕") {
                const [right, rest2] = parseXor(rest.slice(1));
                return [Expr.Xor(left, right), rest2];
            }
            return [left, rest];
        }
        
        function parseOr(tokens) {
	    console.log("parseOr", tokens);
            const [left, rest] = parseAnd(tokens);
            if (rest[0] === "∨") {
                const [right, rest2] = parseOr(rest.slice(1));
                return [Expr.Or(left, right), rest2];
            }
            return [left, rest];
        }
        
        function parseAnd(tokens) {
	    console.log("parseAnd", tokens);
            const [left, rest] = parseTerm(tokens);
            if (rest[0] === "∧") {
                const [right, rest2] = parseAnd(rest.slice(1));
                return [Expr.And(left, right), rest2];
            }
            return [left, rest];
        }
        
        function parseTerm(tokens) {
	    console.log("parseTerm", tokens);
            if (tokens[0] === "(") {
                const [expr, rest] = parseEq(tokens.slice(1));
                if (rest[0] !== ")") throw new Error("Expected closing parenthesis");
                return [expr, rest.slice(1)];
            } else if (tokens[0] === "¬") {
                const [expr, rest] = parseTerm(tokens.slice(1));
                return [Expr.Not(expr), rest];
            } else if (tokens[0] === "0") {
                return [Expr.Bool(false), tokens.slice(1)];
            } else if (tokens[0] === "1") {
                return [Expr.Bool(true), tokens.slice(1)];
            } else if (tokens.length > 0 && !logicalOps.includes(tokens[0])) {
                return [Expr.Var(tokens[0]), tokens.slice(1)];
            }
            throw new Error("Error in func");
        }
        
        function extractVars(expr) {
            const vars = getExpr(expr);
            return [...new Set(vars)].sort();
        }
        
        function getExpr(expr) {
            switch (expr.type) {
                case "Var": return [expr.varname];
                case "And":
                case "Or":
                case "Xor":
                case "Nand":
                case "Nor":
                case "Impl":
                case "Eq":
                    return [...getExpr(expr.left), ...getExpr(expr.right)];
                case "Not": return getExpr(expr.expr);y1*y2*y3*y5 + y1*y2*y4*y5 + y1*y3*y4*y5
                case "Bool": return [];
                default: throw new Error("Unknown expression type");
            }
        }
        
        function eval(expr, vars) {
            const varNames = extractVars(expr);
            const varMap = new Map(varNames.map((name, i) => [name, vars[i]]));
            return evalExpr(expr, varMap);
        }
        
        function evalExpr(expr, varMap) {
            switch (expr.type) {
                case "Var":
                    if (!varMap.has(expr.varname)) throw new Error("Unknown variable");
                    return varMap.get(expr.varname);
                case "And": return evalExpr(expr.left, varMap) && evalExpr(expr.right, varMap);
                case "Or": return evalExpr(expr.left, varMap) || evalExpr(expr.right, varMap);
                case "Xor": return evalExpr(expr.left, varMap) !== evalExpr(expr.right, varMap);
                case "Nand": return !(evalExpr(expr.left, varMap) && evalExpr(expr.right, varMap));
                case "Nor": return !(evalExpr(expr.left, varMap) || evalExpr(expr.right, varMap));
                case "Impl": return !evalExpr(expr.left, varMap) || evalExpr(expr.right, varMap);
                case "Eq": return evalExpr(expr.left, varMap) === evalExpr(expr.right, varMap);
                case "Not": return !evalExpr(expr.expr, varMap);
                case "Bool": return expr.value;
                default: throw new Error("Unknown expression type");
            }
        }
        
        function buildFunc(funcString) {
            const expr = parseExpr(depleteFunc(funcString));
	    console.log("returned expr:", expr);
            return vars => eval(expr, vars);
        }
        
        function buildVars(funcString) {
            if (!funcString) return [];
            return extractVars(parseExpr(depleteFunc(funcString)));
        }
        
        function buildFuncVector(funcString) {
            if (!funcString) return [];
            const vars = buildVars(funcString);
            return generatePoints(vars.length).map(buildFunc(funcString));
        }
        
        function convertVectorToString(vector) {
            return vector.map(b => b ? '1' : '0').join('');
        }
        
        function convertStringToVector(str) {
            return [...str].map(c => c === '1');
        }
        
        function generatePoints(number) {
            if (number <= 0) return [[]];
            const rest = generatePoints(number - 1);
            return [...rest.map(x => [false, ...x]), ...rest.map(x => [true, ...x])];
        }
        
        function numberOfVars(func) {
	    console.log("numberofvars", func);
            return func.length === 0 ? 0 : Math.floor(Math.log2(func.length));
        }

        document.addEventListener('DOMContentLoaded', function() {
            let functionCount = 1;
            let activeInputId = 'input-1';
            let s = null;
            let forceAtlas2 = null;
	
            function prepareFuncs(funcString, faults) {
                return faults.map(([replaceWithOne, substrings]) => {
                    let result = funcString;
                    substrings.forEach(substring => {
			const regex = new RegExp(`(?<!¬)${substring}(?!\\d)`, 'g');
                        const replacement = replaceWithOne ? '1' : '0';
                        result = result.replace(regex, replacement);
                    });
                    return result;
                });
            }

            function createTruthTable(funcString, preparedFuncs, title) {
                if (!funcString || !preparedFuncs) return null;
                
                try {
                    const vars = buildVars(funcString);
                    const func = buildFunc(funcString);
                    const preparedfuncs = preparedFuncs.map(x => buildFunc(x));
		    console.log(preparedFuncs, preparedfuncs);
                    const points = generatePoints(vars.length);
                    
                    const table = document.createElement('table');
                    table.className = 'truth-table';
                    
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    
                    vars.forEach(v => {
                        const th = document.createElement('th');
                        th.textContent = v;
                        headerRow.appendChild(th);
                    });
                    
                    const thResult = document.createElement('th');
                    thResult.textContent = 'f';
                    headerRow.appendChild(thResult);
                    
                    preparedfuncs.forEach((_, i) => {
                        const th = document.createElement('th');
                        th.textContent = `f${i + 1}`;
                        headerRow.appendChild(th);
                    });
                    
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                    
                    const tbody = document.createElement('tbody');
                    
                    points.forEach(point => {
                        const row = document.createElement('tr');
                        
                        point.forEach(val => {
                            const td = document.createElement('td');
                            td.textContent = val ? '1' : '0';
                            row.appendChild(td);
                        });
                        
                        const tdResult = document.createElement('td');
                        tdResult.textContent = func(point) ? '1' : '0';
                        row.appendChild(tdResult);
                        
                        preparedfuncs.forEach(prepFunc => {
                            const td = document.createElement('td');
                            td.textContent = prepFunc(point) ? '1' : '0';
                            row.appendChild(td);
                        });
                        
                        tbody.appendChild(row);
                    });
                    
                    table.appendChild(tbody);
                    
                    const tableContainer = document.createElement('div');
                    const titleElement = document.createElement('div');
                    titleElement.className = 'table-title';
                    titleElement.textContent = title;
                    
                    tableContainer.appendChild(titleElement);
                    tableContainer.appendChild(table);
		    console.log("LogicTable", tableContainer);
                    
		    return [buildFuncVector(funcString), preparedFuncs.map(x => buildFuncVector(x)), points, tableContainer];
                } catch (e) {
                    console.error('Ошибка при создании таблицы:', e);
                    return null;
                }
            }
            
            function createXorTable(funcResults, preparedFuncsResults, points, title) {
                const xorData = [];
                const pointMap = {};
                
                for (let i = 0; i < funcResults.length; i++) {
                    const xorRow = preparedFuncsResults.map(prepFunc => 
                        funcResults[i] ^ prepFunc[i] ? '1' : '0'
                    ).join('');
                    
                    xorData.push(xorRow);
                    
                    if (!pointMap[xorRow]) pointMap[xorRow] = [];
                    pointMap[xorRow].push(points[i]);
                }
            
                const uniqueXor = [...new Set(xorData)];
            
                const xorTable = document.createElement('table');
                xorTable.className = 'xor-table';
                xorTable.style.borderCollapse = 'collapse';
                xorTable.style.margin = '20px 0';
                xorTable.style.fontFamily = 'Arial, sans-serif';
            
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headerRow.style.backgroundColor = '#f2f2f2';
            
                const addHeaderCell = (text) => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.style.padding = '8px 12px';
                    th.style.border = '1px solid #ddd';
                    th.style.textAlign = 'center';
                    headerRow.appendChild(th);
                };
            
                addHeaderCell('Y');
                preparedFuncsResults.forEach((_, i) => addHeaderCell(`XOR ${i+1}`));
                addHeaderCell('Точки');
                
                thead.appendChild(headerRow);
                xorTable.appendChild(thead);
            
                const tbody = document.createElement('tbody');
            
                const addCell = (text, isFirstCol = false) => {
                    const td = document.createElement('td');
                    td.textContent = text;
                    td.style.padding = '8px 12px';
                    td.style.border = '1px solid #ddd';
                    td.style.textAlign = 'center';
                    if (isFirstCol) td.style.fontWeight = 'bold';
                    return td;
                };
            
                uniqueXor.forEach((xorStr, idx) => {
                    const row = document.createElement('tr');
                    if (idx % 2 === 0) row.style.backgroundColor = '#f9f9f9';
            
                    row.appendChild(addCell(`y${idx+1}`, true));
                    xorStr.split('').forEach(bit => row.appendChild(addCell(bit)));
                    const pointsStr = pointMap[xorStr]
                        .map(p => p.map(v => v ? '1' : '0').join(''))
                        .join(', ');
                    row.appendChild(addCell(pointsStr));
                    
                    tbody.appendChild(row);
                });
                
                xorTable.appendChild(tbody);
            
		return {
                    table: xorTable,
                    correspondence: Object.fromEntries(
                        uniqueXor.map((xorStr, idx) => [
                            `y${idx+1}`, 
                            {
                                xor: xorStr,
                                points: pointMap[xorStr]
                            }
                        ])
                    )
                };
            }

            function collectFaults() {
                const faults = [];
                document.querySelectorAll('.function-container').forEach((container, index) => {
                    const input = container.querySelector('.input-field');
                    const ruleType = container.querySelector('.rule-type').value;
                    const faultType = ruleType === 'break' ? false : true;
                    const faultString = input.value.split(',').map(s => s.trim());
                    
                    if (input.value.trim() !== '') {
                        faults.push([faultType, faultString]);
                    }
                });
                
                console.log('Результаты неисправностей:', faults);
                return faults;
            }

            function createFullXorTable(funcResults, preparedFuncsResults, points, title) {
                const allFunctions = [funcResults, ...preparedFuncsResults];
                const funcNames = ['f', ...preparedFuncsResults.map((_, i) => `f${i+1}`)];
            
                const pairs = [];
                for (let i = 0; i < allFunctions.length; i++) {
                    for (let j = i + 1; j < allFunctions.length; j++) {
                        pairs.push([i, j]);
                    }
                }
            
                const xorData = [];
                const pointMap = {};
                
                for (let i = 0; i < points.length; i++) {
                    const xorRow = pairs.map(([idx1, idx2]) => 
                        allFunctions[idx1][i] ^ allFunctions[idx2][i] ? '1' : '0'
                    ).join('');
                    
                    xorData.push(xorRow);
                    
                    if (!pointMap[xorRow]) pointMap[xorRow] = [];
                    pointMap[xorRow].push(points[i]);
                }
            
                const uniqueXor = [...new Set(xorData)];
            
                const xorTable = document.createElement('table');
                xorTable.className = 'xor-table';
                xorTable.style.borderCollapse = 'collapse';
                xorTable.style.margin = '20px 0';
                xorTable.style.fontFamily = 'Arial, sans-serif';
            
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headerRow.style.backgroundColor = '#f2f2f2';
            
                const addHeaderCell = (text) => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.style.padding = '8px 12px';
                    th.style.border = '1px solid #ddd';
                    th.style.textAlign = 'center';
                    headerRow.appendChild(th);
                };
            
                addHeaderCell('Y');
                pairs.forEach(([i, j]) => {
                    addHeaderCell(`${funcNames[i]}⊕${funcNames[j]}`);
                });
                addHeaderCell('Точки');
                
                thead.appendChild(headerRow);
                xorTable.appendChild(thead);
            
                const tbody = document.createElement('tbody');
            
                const addCell = (text, isFirstCol = false) => {
                    const td = document.createElement('td');
                    td.textContent = text;
                    td.style.padding = '8px 12px';
                    td.style.border = '1px solid #ddd';
                    td.style.textAlign = 'center';
                    if (isFirstCol) td.style.fontWeight = 'bold';
                    return td;
                };
            
                uniqueXor.forEach((xorStr, idx) => {
                    const row = document.createElement('tr');
                    if (idx % 2 === 0) row.style.backgroundColor = '#f9f9f9';
            
                    row.appendChild(addCell(`y${idx+1}`, true));
                    
                    xorStr.split('').forEach(bit => row.appendChild(addCell(bit)));
                    
                    const pointsStr = pointMap[xorStr]
                        .map(p => p.map(v => v ? '1' : '0').join(''))
                        .join(', ');
                    row.appendChild(addCell(pointsStr));
                    
                    tbody.appendChild(row);
                });
                
                xorTable.appendChild(tbody);
            
                return {
                    table: xorTable,
                    correspondence: Object.fromEntries(
                        uniqueXor.map((xorStr, idx) => [
                            `y${idx+1}`, 
                            {
                                xor: xorStr,
                                points: pointMap[xorStr],
                                xorPairs: pairs.map((pair, i) => ({
                                    pair: `${funcNames[pair[0]]}⊕${funcNames[pair[1]]}`,
                                    value: xorStr[i]
                                }))
                            }
                        ])
                    )
                };
            }

            function buildCNF(xorTableResult) {
                const { correspondence } = xorTableResult;
                const cnfParts = [];
                
                const columns = [];
                const headerCells = xorTableResult.table.querySelectorAll('thead th:not(:first-child):not(:last-child)');
                headerCells.forEach(th => columns.push(th.textContent));
                
                const columnData = {};
                columns.forEach((col, colIndex) => {
                    columnData[col] = [];
                    Object.entries(correspondence).forEach(([y, data]) => {
                        if (data.xor[colIndex] === '1') {
                            columnData[col].push(y);
                        }
                    });
                });
                
                const cnfClauses = [];
                Object.entries(columnData).forEach(([col, ys]) => {
                    if (ys.length > 0) {
                        cnfClauses.push(`(${ys.join(' + ')})`);
                    }
                });
                
                const fullCNF = cnfClauses.join(' * ');
                
                const cnfContainer = document.createElement('div');
                cnfContainer.className = 'cnf-container';
                
                const title = document.createElement('h3');
                title.textContent = 'КНФ:';
                cnfContainer.appendChild(title);
                
                const cnfElement = document.createElement('div');
                cnfElement.className = 'cnf-formula';
                cnfElement.textContent = fullCNF || '1'; // Если нет условий, КНФ = 1
                cnfContainer.appendChild(cnfElement);
                
                const explanation = document.createElement('div');
                explanation.className = 'cnf-explanation';
                explanation.innerHTML = `
                    <p>Где:</p>
                    <ul>
                        ${Object.entries(correspondence).map(([y, data]) => 
                            `<li>${y} = ${data.points.map(p => p.map(v => v ? '1' : '0').join('')).join(', ')}</li>`
                        ).join('')}
                    </ul>
                `;
                cnfContainer.appendChild(explanation);
                
                return {
                    cnf: fullCNF,
                    element: cnfContainer,
                    columnData,
                    correspondence
                };
            }

            function expandCNF(cnf) {
                let conjuncts = cnf.split('*')
                    .map(c => c.trim().replace(/[()]/g, ''))
                    .filter(c => c.length > 0);
                if (conjuncts.length === 0) return '';
                if (conjuncts.length === 1) return conjuncts[0];
                let currentExpr = conjuncts[0];
                for (let i = 1; i < conjuncts.length; i++) {
                    currentExpr = multiplyTwoExpressions(currentExpr, conjuncts[i]);
                    currentExpr = applyAbsorption(currentExpr);
                }
                return currentExpr;
            }
            
            function multiplyTwoExpressions(expr1, expr2) {
                const terms1 = expr1.split('+').map(t => t.trim());
                const terms2 = expr2.split('+').map(t => t.trim());
                let result = [];
                for (const t1 of terms1) {
                    for (const t2 of terms2) {
                        const combined = [...new Set([...t1.split('*'), ...t2.split('*')])]
                            .filter(v => v)
                            .sort()
                            .join('*');
                        result.push(combined);
                    }
                }
                return result.join(' + ');
            }
            
            function applyAbsorption(expr) {
                const terms = expr.split('+').map(t => t.trim().split('*'));
                const absorbedTerms = [];
                terms.forEach(currentTerm => {
                    const isAbsorbed = absorbedTerms.some(existingTerm => {
                        return existingTerm.every(v => currentTerm.includes(v));
                    });
                    if (!isAbsorbed) {
                        for (let i = absorbedTerms.length - 1; i >= 0; i--) {
                            if (currentTerm.every(v => absorbedTerms[i].includes(v))) {
                                absorbedTerms.splice(i, 1);
                            }
                        }
                        absorbedTerms.push(currentTerm);
                    }
                });
                return absorbedTerms
                    .map(term => term.sort().join('*'))
                    .join(' + ');
            }
            
            document.getElementById('build-knf').addEventListener('click', function() {
                const funcString = document.getElementById('independent-input').value.trim();
                const tablesContainer = document.getElementById('tables-container');
                tablesContainer.innerHTML = '';
                
                const faults = collectFaults();
		const preparedFuncs = prepareFuncs(funcString, faults); 
                
                const [func, preparedfuncs, points, testTable] = createTruthTable(funcString, preparedFuncs, 'Проверочный тест');
                if (testTable) {
                    tablesContainer.appendChild(testTable);
		    const result = createXorTable(func, preparedfuncs, points, 'Матрица различий');
                    tablesContainer.appendChild(result.table);
		    const unoptimizedCNF = buildCNF(result);
		    console.log(unoptimizedCNF);
		    const res = expandCNF(unoptimizedCNF.cnf);
		    console.log(res);
		    showResult(unoptimizedCNF.cnf + ' => *магия* => ' + res);
                } else {
                    alert('Невозможно построить таблицу для введенной функции');
                }
            });
            
            document.getElementById('reset-layout').addEventListener('click', function() {
                const funcString = document.getElementById('independent-input').value.trim();
                const tablesContainer = document.getElementById('tables-container');
                tablesContainer.innerHTML = '';
                
                const faults = collectFaults();
		const preparedFuncs = prepareFuncs(funcString, faults); 
                
                const [func, preparedfuncs, points, diagnosticTable] = createTruthTable(funcString, preparedFuncs, 'Диагностический тест');
                if (diagnosticTable) {
                    tablesContainer.appendChild(diagnosticTable);
		    const result = createFullXorTable(func, preparedfuncs, points, 'Матрица различий');
                    tablesContainer.appendChild(result.table);
		    const unoptimizedCNF = buildCNF(result);
		    console.log(unoptimizedCNF);
		    const res = expandCNF(unoptimizedCNF.cnf);
		    console.log(res);
		    showResult(unoptimizedCNF.cnf + ' => *магия* => ' + res);
                } else {
                    alert('Невозможно построить таблицу для введенной функции');
                }
            });
            
            function setActiveInput(inputId) {
                activeInputId = inputId;
                document.querySelectorAll('.keyboard-container').forEach(kb => {
                    kb.classList.remove('active-keyboard');
                });
                
                if (inputId.startsWith('input-')) {
                    const functionContainer = document.getElementById(inputId).closest('.function-container');
                    const keyboard = functionContainer.querySelector('.keyboard-container');
                    if (keyboard) keyboard.classList.add('active-keyboard');
                } else if (inputId === 'independent-input') {
                    document.getElementById('independent-keyboard').classList.add('active-keyboard');
                }
            }

	    function showResult(resultText) {
		const resultContainer = document.getElementById('result-container');
		resultContainer.innerHTML = '';
		const resultElement = document.createElement('div');
		resultElement.textContent = resultText
		resultContainer.appendChild(resultElement);
	    }
            
            function insertSymbol(symbol) {
                const activeInput = document.getElementById(activeInputId);
                if (activeInput) {
                    const startPos = activeInput.selectionStart;
                    const endPos = activeInput.selectionEnd;
                    const currentValue = activeInput.value;
                    
                    activeInput.value = currentValue.substring(0, startPos) + symbol + currentValue.substring(endPos);
                    
                    setTimeout(() => {
                        activeInput.selectionStart = activeInput.selectionEnd = startPos + symbol.length;
                        activeInput.focus();
                    }, 0);
                }
            }
            
            document.getElementById('independent-input').addEventListener('focus', function() {
                setActiveInput('independent-input');
            });
            
            document.getElementById('independent-clear').addEventListener('click', function() {
                document.getElementById('independent-input').value = '';
                document.getElementById('independent-input').focus();
            });
            
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('symbol-button')) {
                    const symbol = e.target.getAttribute('data-symbol');
                    insertSymbol(symbol);
                }
                
                if (e.target.classList.contains('clear-button') && e.target.id !== 'independent-clear') {
                    const functionContainer = e.target.closest('.function-container');
                    const inputField = functionContainer.querySelector('.input-field');
                    inputField.value = '';
                    inputField.focus();
                    setActiveInput(inputField.id);
                }
            });
            
            document.addEventListener('focusin', function(e) {
                if (e.target.classList.contains('input-field')) {
                    setActiveInput(e.target.id);
                }
            });
            
            document.getElementById('add-function').addEventListener('click', function() {
                functionCount++;
                const newFunction = document.createElement('div');
                newFunction.className = 'function-container';
                newFunction.id = `function-${functionCount}`;
                
                newFunction.innerHTML = `
                    <select class="rule-type" style="margin-right: 10px; padding: 5px;">
                        <option value="break">Обрыв</option>
                        <option value="make">Замыкание</option>
                    </select>
                    <span style="margin-right: 10px;">контактов</span>
                    <input type="text" class="input-field" id="input-${functionCount}">
                    <button class="clear-button">Очистить</button>
                    <div class="keyboard-container" id="keyboard-${functionCount}">
                        <div class="button-row">
                            <button class="symbol-button" data-symbol="x1">x1</button>
                            <button class="symbol-button" data-symbol="x2">x2</button>
                            <button class="symbol-button" data-symbol="x3">x3</button>
                            <button class="symbol-button" data-symbol="x4">x4</button>
                            <button class="symbol-button" data-symbol="¬">¬</button>
                            <button class="symbol-button" data-symbol=",">,</button>
                        </div>
                    </div>
                    <button class="remove-button">Удалить неисправность</button>
                `;
                
                document.getElementById('functions-container').appendChild(newFunction);
                
                const newInput = document.getElementById(`input-${functionCount}`);
                newInput.focus();
                setActiveInput(newInput.id);
            });
            
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('remove-button')) {
                    const functionContainer = e.target.closest('.function-container');
                    if (functionContainer && functionContainer.id !== 'function-1') {
                        functionContainer.remove();
                    }
                }
            });
            
            setActiveInput('input-1');
        });
    </script>
</body>
</html>
